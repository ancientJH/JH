#ÂÆö‰πâÊùêÊñôÂèÇÊï∞Áõ∏ÂÖ≥ÁöÑÁªìÊûÑ‰Ωì
struct Material{T}
    E::T  # Young's modulus
    G::T  # Shear modulus = Œº (Lame constant)
    K::T  # Bulk modulus
    Œª::T  # Lame constant
    ŒΩ::T  # Poisson's ratio
    Gc::T # Fracture Toughness
    œÉc::T # Strength
    ‚Ñì::T  # Phase field length scale
    s::T  # parameter for Hughes degradation 
    a‚ÇÅ::T # parameter for Wu degradation 
    flag::StrainDecomp
    flagD::DegradType
    dim::Int64
end
function Material(E, ŒΩ, Gc, œÉc, ‚Ñì, s, flag, flagD, dim)
    G = E / 2(1 + ŒΩ);
    K = E / 3(1 - 2ŒΩ);
    Œª = K - 2G / 3;
    a‚ÇÅ = 27E*Gc/(128œÉc^2*‚Ñì‚ÇÄ);
    return Material(E, G, K, Œª, ŒΩ, Gc, œÉc, ‚Ñì, s, a‚ÇÅ, flag, flagD, dim)
end

#ÂÆö‰πâÂéÜÂè≤ÂèòÈáèÁªìÊûÑ‰Ωì
struct HistoryVariable{T}
	H::T # History variable
	œï::T #phase field variable from last increment
end
function HistoryVariable()
	return HistoryVariable(0.0, 0.0)
end
#ÂÆö‰πâÊ±ÇËß£ÂèÇÊï∞ÁªìÊûÑ‰Ωì
mutable struct SolverState{T,F}
    loadsteps::Vector{F}
    nitr_inner::T
    nitr_outer::T
    TOL_u::F
    TOL_œï::F
end
function create_solver_state(loadsteps, nitr_inner, nitr_outer, TOL_u, TOL_œï)
    return SolverState(loadsteps, nitr_inner, nitr_outer, TOL_u, TOL_œï)
end
#ÂÆö‰πâËæìÂá∫ÂèÇÊï∞ÁªìÊûÑ‰Ωì
mutable struct OutputVariables{T}
    plotframe::T
    totalIterations_outer::T
    totalIterations_œï::T
    totalIterations_u::T
    plotFrequency::T
    historyFrequency::T
    a0::Float64
    CrackDir::T
    OutputSet::String
end
#ËæìÂá∫ÂèÇÊï∞ÁªìÊûÑ‰ΩìÁöÑÂàùÂßãÂåñ
function OutputVariables(field_frequency, history_frequency, a0, CrackDir, outputset)
    return OutputVariables(0, 0, 0, 0, field_frequency, history_frequency, a0, CrackDir, outputset)
end

function assemble_element_u!(Ke, Re, cellvalues_u, ue, material, state, state_old)
    nbase_u = getnbasefunctions(cellvalues_u);
    for q_point in 1:getnquadpoints(cellvalues_u)
        dŒ©·µ§ = getdetJdV(cellvalues_u, q_point)
        if material.dim == 2
            Œµ_PlaneStrain = function_symmetric_gradient(cellvalues_u, q_point, ue)
            ‚àáÀ¢u = SymmetricTensor{2,3,Float64}((Œµ_PlaneStrain[1, 1], Œµ_PlaneStrain[1, 2], 0.0,Œµ_PlaneStrain[2, 2], 0.0, 0.0))
        elseif material.dim == 3
            ‚àáÀ¢u = function_symmetric_gradient(cellvalues_u, q_point, ue)
        else
            error("Invalid element dimension")
        end

        œï = state[q_point].œï
        gd, _, _ = Degradation(œï, material);
        Œ®‚Å∫, D·µâ, œÉ = Constitutive(‚àáÀ¢u, material, gd);
        H = max(Œ®‚Å∫, state_old[q_point].H);
        state[q_point] = HistoryVariable(H, œï);

        for i in 1:nbase_u
            if material.dim == 2
                Œ¥Œµ_2d = shape_symmetric_gradient(cellvalues_u, q_point, i);
                Œ¥Œµ = SymmetricTensor{2,3,Float64}((Œ¥Œµ_2d[1, 1], Œ¥Œµ_2d[1, 2], 0.0,Œ¥Œµ_2d[2, 2], 0.0, 0.0));
            else
                Œ¥Œµ = shape_symmetric_gradient(cellvalues_u, q_point, i);
            end
            for j in 1:i
                if material.dim == 2
                    Œµ_2d = shape_symmetric_gradient(cellvalues_u, q_point, j);
                    ŒµÃÑu = SymmetricTensor{2,3,Float64}((Œµ_2d[1, 1], Œµ_2d[1, 2], 0.0,
                        Œµ_2d[2, 2], 0.0, 0.0));
                else
                    ŒµÃÑu = shape_symmetric_gradient(cellvalues_u, q_point, j);
                end
                Ke[i, j] += Œ¥Œµ ‚ä° D·µâ ‚ä° ŒµÃÑu * dŒ©·µ§;
            end
            Re[i] += Œ¥Œµ ‚ä° œÉ * dŒ©·µ§;
        end
    end
    symmetrize_lower!(Ke)
    return Ke, Re
end

function assemble_residual_u!(Re::Vector, cellvalues_u,ue::Vector, material::Material, state, state_old, store::Bool)
    nbase_u = getnbasefunctions(cellvalues_u);
    for q_point in 1:getnquadpoints(cellvalues_u)
        dŒ©·µ§ = getdetJdV(cellvalues_u, q_point);
        œï = state[q_point].œï;
        if material.dim == 2
            Œµ_PlaneStrain = function_symmetric_gradient(cellvalues_u, q_point, ue);
            ‚àáÀ¢u = SymmetricTensor{2,3,Float64}((Œµ_PlaneStrain[1, 1], Œµ_PlaneStrain[1, 2], 0.0, Œµ_PlaneStrain[2, 2], 0.0, 0.0));
        elseif material.dim == 3
            ‚àáÀ¢u = function_symmetric_gradient(cellvalues_u, q_point, ue);
        else
            error("Invalid element dimension");
        end
        
        gd, _, _ = Degradation(œï, material);
        Œ®‚Å∫, _, œÉ, _ = Constitutive(‚àáÀ¢u, material, gd);
        H = max(Œ®‚Å∫, state_old[q_point].H);
        if store
            state[q_point] = HistoryVariable(H, œï);
        end
        for i in 1:nbase_u
            if material.dim == 2
                Œ¥Œµ_2d = shape_symmetric_gradient(cellvalues_u, q_point, i);
                Œ¥Œµ = SymmetricTensor{2,3,Float64}((Œ¥Œµ_2d[1, 1], Œ¥Œµ_2d[1, 2], 0.0, Œ¥Œµ_2d[2, 2], 0.0, 0.0));
            else
                Œ¥Œµ = shape_symmetric_gradient(cellvalues_u, q_point, i);
            end
            Re[i] += (Œ¥Œµ ‚ä° œÉ) * dŒ©·µ§;
        end
    end
    return Re
end

function assemble_element_œï!(Ke::Matrix, Re::Vector, cellvalues_œï, œïe::Vector, material::Material, state, state_old)
    nbase_œï = getnbasefunctions(cellvalues_œï);
    Gc = material.Gc;
    ‚Ñì = material.‚Ñì;
    for q_point in 1:getnquadpoints(cellvalues_œï)
        dŒ©·µ© = getdetJdV(cellvalues_œï, q_point);
        œï = function_value(cellvalues_œï, q_point, œïe);
        ‚àáœï = function_gradient(cellvalues_œï, q_point, œïe);

        H = state[q_point].H;
        state[q_point] = HistoryVariable(H, œï);
        _, gd‚Ä≤, gd‚Ä≤‚Ä≤ = Degradation(œï, material);
        for i in 1:nbase_œï
            Œ¥œï = shape_value(cellvalues_œï, q_point, i);
            ‚àáŒ¥œï = shape_gradient(cellvalues_œï, q_point, i);
            for j in 1:i
                œï‚Ä≤ = shape_value(cellvalues_œï, q_point, j);
                ‚àáœï‚Ä≤ = shape_gradient(cellvalues_œï, q_point, j);
                Ke[i, j] += (gd‚Ä≤‚Ä≤ * œï‚Ä≤ * H * Œ¥œï + Gc / ‚Ñì * Œ¥œï * œï‚Ä≤ + Gc * ‚Ñì * ‚àáŒ¥œï ‚ãÖ ‚àáœï‚Ä≤) * dŒ©·µ©;
            end
            Re[i] += (gd‚Ä≤ * H * Œ¥œï + Gc / ‚Ñì * Œ¥œï * œï + Gc * ‚Ñì * ‚àáŒ¥œï ‚ãÖ ‚àáœï) * dŒ©·µ©;
        end
    end
    symmetrize_lower!(Ke)
    return Ke, Re
end

function assemble_residual_œï!(Re::Vector, cellvalues_œï, œïe::Vector, material::Material, state, state_old, store::Bool)
    nbase_œï = getnbasefunctions(cellvalues_œï);
    Gc = material.Gc;
    ‚Ñì = material.‚Ñì;
    for q_point in 1:getnquadpoints(cellvalues_œï);
        dŒ©·µ© = getdetJdV(cellvalues_œï, q_point);
        œï = function_value(cellvalues_œï, q_point, œïe);
        ‚àáœï = function_gradient(cellvalues_œï, q_point, œïe);
        H = state[q_point].H;
        if store
            state[q_point] = HistoryVariable(H, œï);
        end       
        _, gd‚Ä≤, _ = Degradation(œï, material);
        for i in 1:nbase_œï
            Œ¥œï = shape_value(cellvalues_œï, q_point, i);
            ‚àáŒ¥œï = shape_gradient(cellvalues_œï, q_point, i);
            Re[i] += (gd‚Ä≤ * H * Œ¥œï +  Gc / ‚Ñì * Œ¥œï * œï +  Gc * ‚Ñì * ‚àáŒ¥œï ‚ãÖ ‚àáœï) * dŒ©·µ©;
        end
    end
    return Re
end

function symmetrize_lower!(K)
    for i in 1:size(K,1)
        for j in i+1:size(K,1)
            K[i,j] = K[j,i]
        end
    end
end


function assemble_global_r(q::Vector, cellvalues, dh::DofHandler, material::Material, states, states_old, tag::String, store::Bool=true)
    nbase = getnbasefunctions(cellvalues);
    Re = zeros(nbase);
    R = zeros(ndofs(dh));
    for (i, cell) in enumerate(CellIterator(dh))
        reinit!(cellvalues, cell);
        fill!(Re, 0);
        eldofs = celldofs(cell);
        qe = q[eldofs];
        state = @view states[:, i];
        state_old = @view states_old[:, i];
        if tag == "u"
            assemble_residual_u!(Re, cellvalues, qe, material, state, state_old, store);
        elseif tag == "œï"
            assemble_residual_œï!(Re, cellvalues, qe, material, state, state_old, store);
        end
        R[eldofs] += Re;
    end
    return R
end;

function CreatCellvalues(ElementShape, ElementOrder, QuadratureOrder, dim)
	ip = Lagrange{dim, ElementShape, ElementOrder}()
	qr = QuadratureRule{dim, ElementShape}(QuadratureOrder)
	cellvalues_u = CellVectorValues(qr, ip)
	cellvalues_œï = CellScalarValues(qr, ip)
	return ip, qr, cellvalues_u, cellvalues_œï
end

function CreatBC(grid, dim)
	dbc‚ÇÅ = Dirichlet(:u, getfaceset(grid, "top"), (x, t) -> t, 2)
	dbc‚ÇÇ = Dirichlet(:u, getfaceset(grid, "bottom"), (x, t) -> [0, 0], [1, 2])

	dh_u = DofHandler(grid)
	add!(dh_u, :u, dim) 
	close!(dh_u)

	bch_u = ConstraintHandler(dh_u)
	add!(bch_u, dbc‚ÇÅ)
	add!(bch_u, dbc‚ÇÇ) 
	close!(bch_u)
	update!(bch_u, 0.0)

	dh_œï = DofHandler(grid)
	add!(dh_œï, :œï, 1) 
	close!(dh_œï)

	bch_œï = ConstraintHandler(dh_œï) 
	close!(bch_œï)
	update!(bch_œï, 0.0)

    return dh_u, dh_œï, bch_u, bch_œï
end

function Degradation(œï, mat)
    # kmin = 1e-15;
    kmin = 1e-8;
    flagD = mat.flagD
    if flagD == QuadraticDegradation
        gd = (1.0 - œï)^2 + kmin; 
        gd‚Ä≤ = -2.0(1.0 - œï);
        gd‚Ä≤‚Ä≤ = 2.0;
    elseif flagD == WuDegradation
        a‚ÇÅ = mat.a‚ÇÅ;
        fact = (1.0 - œï)^2 + a‚ÇÅ*œï*(1 - 0.5œï);
        gd = (1.0 - œï)^2/fact + kmin;
        gd‚Ä≤ = -a‚ÇÅ*(1.0 - œï)/fact^2;
        gd‚Ä≤‚Ä≤ = 2a‚ÇÅ^2/fact^3 - 3a‚ÇÅ/fact^2;
        gd‚Ä≤‚Ä≤ = gd‚Ä≤‚Ä≤>0 ? gd‚Ä≤‚Ä≤ : 0;
    end
    return gd, gd‚Ä≤, gd‚Ä≤‚Ä≤
end

function Constitutive(Œµ::SymmetricTensor{2,3,Float64}, mat, gdn)
    Heaviside(x::AbstractFloat) = ifelse(x < 0, zero(x), ifelse(x > 0, one(x), oftype(x, 0.5)))
    flag = mat.flag
    if flag == Isotropic
        Œº = mat.G;
        Œª = mat.Œª;
        I = one(SymmetricTensor{2,3});
        ùïÄ = one(SymmetricTensor{4,3});
        D = Œª * I ‚äó I + 2Œº * ùïÄ;
        Œ®‚Å∫ = 0.5 * Œµ ‚ä° D ‚ä° Œµ;
        D·µâ = gdn * D; 
        œÉ = D·µâ ‚ä° Œµ;
        œÉ‚Å∫ = œÉ;
    elseif flag == VolDev 
        K = mat.K;
        G = mat.G;
        I = one(SymmetricTensor{2,3});
        ùïÄ = one(SymmetricTensor{4,3});
        D‚Å∫ = K * Heaviside(tr(Œµ)) * I ‚äó I + 2G * (ùïÄ - 1 / 3 * I ‚äó I);
        D‚Åª = K * Heaviside(-tr(Œµ)) * I ‚äó I;
        Œ®‚Å∫ = tr(Œµ) >0 ? 0.5*K*tr(Œµ)^2 + G*dev(Œµ) ‚ä° dev(Œµ) : G*dev(Œµ) ‚ä° dev(Œµ);
        œÉ‚Å∫ = tr(Œµ) >0 ? K*tr(Œµ)*I + 2G*dev(Œµ) : 2G*dev(Œµ); 
        œÉ‚Åª = tr(Œµ) <0 ? K*tr(Œµ)*I  : zero(Tensor{2, 3}); 
        D·µâ = gdn * D‚Å∫ + D‚Åª;
        œÉ = gdn *œÉ‚Å∫ + œÉ‚Åª;
    elseif flag == Spectral 
        Œµ‚Çô, V‚Çô = eigen(Œµ);        # Œµ‚Çô = eigvals(Œµ)
        Œº = mat.G;
        Œª = mat.Œª;
        bracket‚Çä(a::AbstractFloat) = a > 0 ? a : 0;
        bracket‚Çã(a::AbstractFloat) = a < 0 ? a : 0;
        H‚ÇÅ‚ÇÇ‚Å∫(x::AbstractFloat, y::AbstractFloat) = x ‚â† y ? (bracket‚Çä(x) - bracket‚Çä(y)) / (x - y) : Heaviside(x);
        H‚ÇÅ‚ÇÇ‚Åª(x::AbstractFloat, y::AbstractFloat) = x ‚â† y ? (bracket‚Çã(x) - bracket‚Çã(y)) / (x - y) : Heaviside(-x);
        I = one(SymmetricTensor{2,3});
        Œ®‚Å∫ = tr(Œµ) >0 ? Œª/2*tr(Œµ)^2 : 0.0;
        for e in Œµ‚Çô;Œ®‚Å∫ += e>0 ? Œº*e^2 : 0.0;end;
        œÉ‚Å∫ = Œª*bracket‚Çä(tr(Œµ))*I + 2Œº*(bracket‚Çä(Œµ‚Çô[1])*V‚Çô[:,1]‚äóV‚Çô[:,1] + bracket‚Çä(Œµ‚Çô[2])*V‚Çô[:,2]‚äóV‚Çô[:,2] + bracket‚Çä(Œµ‚Çô[3])*V‚Çô[:,3]‚äóV‚Çô[:,3]);
        œÉ‚Åª = Œª*bracket‚Çã(tr(Œµ))*I + 2Œº*(bracket‚Çã(Œµ‚Çô[1])*V‚Çô[:,1]‚äóV‚Çô[:,1] + bracket‚Çã(Œµ‚Çô[2])*V‚Çô[:,2]‚äóV‚Çô[:,2] + bracket‚Çã(Œµ‚Çô[3])*V‚Çô[:,3]‚äóV‚Çô[:,3]);
        D‚Å∫ = Œª * Heaviside(tr(Œµ)) * I ‚äó I;
        D‚Åª = Œª * Heaviside(-tr(Œµ)) * I ‚äó I;
        for a in 1:3
            D‚Å∫ += 2Œº * Heaviside(Œµ‚Çô[a]) * (V‚Çô[:, a] ‚äó V‚Çô[:, a]) ‚äó (V‚Çô[:, a] ‚äó V‚Çô[:, a]);
            D‚Åª += 2Œº * Heaviside(-Œµ‚Çô[a]) * (V‚Çô[:, a] ‚äó V‚Çô[:, a]) ‚äó (V‚Çô[:, a] ‚äó V‚Çô[:, a]);
            for b in 1:3
                if a ‚â† b
                    D‚Å∫ += Œº * H‚ÇÅ‚ÇÇ‚Å∫(Œµ‚Çô[a], Œµ‚Çô[b]) * ((V‚Çô[:, a] ‚äó V‚Çô[:, b]) ‚äó (V‚Çô[:, a] ‚äó V‚Çô[:, b]) + (V‚Çô[:, a] ‚äó V‚Çô[:, b]) ‚äó (V‚Çô[:, b] ‚äó V‚Çô[:, a]));
                    D‚Åª += Œº * H‚ÇÅ‚ÇÇ‚Åª(Œµ‚Çô[a], Œµ‚Çô[b]) * ((V‚Çô[:, a] ‚äó V‚Çô[:, b]) ‚äó (V‚Çô[:, a] ‚äó V‚Çô[:, b]) + (V‚Çô[:, a] ‚äó V‚Çô[:, b]) ‚äó (V‚Çô[:, b] ‚äó V‚Çô[:, a]));
                end
            end
        end
        D·µâ = gdn * D‚Å∫ + D‚Åª;
        œÉ = gdn *œÉ‚Å∫ + œÉ‚Åª;
    end
    return Œ®‚Å∫, D·µâ, œÉ, œÉ‚Å∫
end

function Newton_raphson!(q::Vector, K::SparseMatrixCSC, cellvalues, dh::DofHandler, ch::ConstraintHandler, grid::Grid, Mat::Material, states, states_old, Ru_first, Rœï_first, tag::String)
    iterations = 0;
    for nitr = 1:(solver.nitr_inner+1);
        if nitr > solver.nitr_inner;
            error("Reached maximum Newton iterations, aborting");
            break;
        end;
        K, r = assemble_global(q, cellvalues, K, dh, Mat, states, states_old, tag::String);
        apply_zero!(K, r, ch);
        norm_r = norm(r[Ferrite.free_dofs(ch)]);  # norm_r = maximum(abs.(r[Ferrite.free_dofs(ch)]))
        if tag =="u"
            TOL = solver.TOL_u * Ru_first;
        elseif tag =="œï"
            TOL = solver.TOL_œï * Rœï_first;
        end
        if (norm_r < TOL) && (nitr > 1);
            break;
        end
        iterations += 1;
        K_active = K[Ferrite.free_dofs(ch),Ferrite.free_dofs(ch)];
		r_active =  r[Ferrite.free_dofs(ch)];
        # Œîq = K_active \ r_active;
        q[Ferrite.free_dofs(ch)] -= K_active \ r_active;
    end
        print(tag*" converged in $iterations iterations \n");
    return q, iterations, K
end

function assemble_global(q::Vector, cellvalues, K::SparseMatrixCSC, dh::DofHandler, material::Material, states, states_old, tag::String)
    nbase = getnbasefunctions(cellvalues);

    Ke = zeros(nbase, nbase);
    Re = zeros(nbase);
    R = zeros(ndofs(dh));
    assembler = start_assemble(K, R);

    for (i, cell) in enumerate(CellIterator(dh))
        reinit!(cellvalues, cell);
        fill!(Ke, 0);
        fill!(Re, 0);
        eldofs = celldofs(cell);
        qe = q[eldofs];
        state = @view states[:, i];
        state_old = @view states_old[:, i];
        if tag == "u"
            assemble_element_u!(Ke, Re, cellvalues, qe, material, state, state_old);
        elseif  tag == "œï"
            assemble_element_œï!(Ke, Re, cellvalues, qe, material, state, state_old);
        end
        assemble!(assembler, eldofs, Ke, Re);
        
    end
    return K, R
end;

function Masterstep_u!(u, œï, K, R_u, R_œï, cellvalues_u, cellvalues_œï, dh, dh_u, dh_œï, ch, ch_u, ch_œï, material, states, states_old, flag_eta)
    @inbounds begin
        u_free = free_dofs(ch_u)
        œï_free = free_dofs(ch_œï)
        n_u = ndofs(dh_u)
        q = vcat(u, œï) 
        K = assemble_global_K_old(q, K, cellvalues_u, cellvalues_œï, dh, material, states, states_old)

        Kuu = @view K[1:n_u, 1:n_u]
        Kuœï = @view K[1:n_u, n_u+1:end]
        Kœïu = @view K[n_u+1:end, 1:n_u]
        Kœïœï = @view K[n_u+1:end, n_u+1:end]
        K_uu = @view (Kuu[u_free, u_free])
        K_uœï = @view (Kuœï[u_free, œï_free])
        K_œïu = @view (Kœïu[œï_free, u_free])
        K_œïœï = @view (Kœïœï[œï_free, œï_free])

        K_uu = sparse(Symmetric(K_uu))
        K_œïœï = sparse(Symmetric(K_œïœï))
        K_uu_fact = cholesky(K_uu)
        K_œïœï_fact = cholesky(K_œïœï)
        eta = 1;
        if flag_eta == 1
            rho = cal_rho1(K_uu, K_œïœï, K_uœï, K_œïu)
            if rho < 1
                println("eta = ", eta)
            elseif rho > 1
                eta = 0.9/sqrt(rho);
                println("eta = ", eta)
            end
        end
        y_active = -(K_uu_fact \ (R_u - eta * K_uœï * (K_œïœï_fact \ R_œï)))
        Œîu_active = gmres_user(K_uu_fact, K_œïœï_fact, eta * K_uœï, eta * K_œïu, y_active; max_iter=50, tol=1e-6)
        Œîu = zeros(ndofs(dh_u))
        Œîu[u_free] .= Œîu_active   
    end
    return Œîu
end

function assemble_coupled_K(u, œï, cellvalues_u, cellvalues_œï, dh_u, dh_œï, material, states, states_old)
    # ËÆ°ÁÆóÊÄªËá™Áî±Â∫¶Ôºö‰ΩçÁßª (u) + Áõ∏Âú∫ (œï)
    nu = ndofs(dh_u)
    nœï = ndofs(dh_œï)
    n_dofs = nu + nœï
    
    # ÂºÄÂßãÁªÑË£ÖÔºå‰∏çÊòæÂºèÊåáÂÆöÁ®ÄÁñèÊ®°Âºè
    assembler = start_assemble()
    
    # ÂÖÉÁ¥†Á∫ßÁöÑÁªÑË£Ö
    nbase_u = getnbasefunctions(cellvalues_u)  # ‰ΩçÁßªÂú∫ÁöÑÂü∫ÂáΩÊï∞Êï∞Èáè
    nbase_œï = getnbasefunctions(cellvalues_œï)  # Áõ∏Âú∫Âü∫ÂáΩÊï∞Êï∞Èáè
    Ke = BlockArray(zeros(nbase_u + nbase_œï, nbase_u + nbase_œï), [nbase_u, nbase_œï], [nbase_u, nbase_œï])
    
    # ÈÅçÂéÜÂçïÂÖÉ
    for (i, cell) in enumerate(CellIterator(dh_u.grid))
        fill!(Ke, 0)  # Ê∏ÖÁ©∫ÂÖÉÁ¥†ÂàöÂ∫¶Áü©Èòµ
        reinit!(cellvalues_u, cell)  # ÈáçÁΩÆÂçïÂÖÉÂÄº
        reinit!(cellvalues_œï, cell)
        
        # Ëé∑ÂèñÂçïÂÖÉËá™Áî±Â∫¶
        eldofs_u = celldofs(dh_u, i)
        eldofs_œï = celldofs(dh_œï, i)
        eldofs = vcat(eldofs_u, eldofs_œï)  # ÂêàÂπ∂Ëá™Áî±Â∫¶
        
        # Ëé∑ÂèñÂçïÂÖÉËß£ÂêëÈáè
        ue = u[eldofs_u]
        œïe = œï[eldofs_œï]
        qe = vcat(ue, œïe)  # ÂêàÂπ∂Ëß£ÂêëÈáè
        
        state = @view states[:, i]
        state_old = @view states_old[:, i]
        
        # ÁªÑË£ÖÂÖÉÁ¥†ÂàöÂ∫¶Áü©Èòµ
        assemble_element_ke_old!(Ke, cell, cellvalues_u, cellvalues_œï, qe, material, state, state_old)
        
        # Â∞ÜÂÖÉÁ¥†Áü©ÈòµÁªÑË£ÖÂà∞ÂÖ®Â±ÄÁü©Èòµ
        assemble!(assembler, eldofs, Ke)
    end
    
    # ÂÆåÊàêÁªÑË£ÖÂπ∂ËøîÂõûÂÖ®Â±ÄÁü©Èòµ
    K, _ = end_assemble(assembler)
    return K
end

function assemble_element_ke_old!(Ke, cell, cellvalues_u, cellvalues_œï, qe, material, state, state_old)
    nbase_u = getnbasefunctions(cellvalues_u)
    nbase_œï = getnbasefunctions(cellvalues_œï)
    u‚ñÑ, œï‚ñÑ = 1, 2 #‰ΩçÁßªÊòØÂùó1ÔºåÁõ∏Âú∫ÊòØÂùó2
    reinit!(cellvalues_u, cell)
    reinit!(cellvalues_œï, cell)

    œïe = qe[nbase_u+1:end]
    ue = qe[1:nbase_u]

    Gc = material.Gc
    ‚Ñì = material.‚Ñì

    for q_point in 1:getnquadpoints(cellvalues_u)
        dŒ©·µ§ = getdetJdV(cellvalues_u, q_point)
        if material.dim == 2
            Œµ_PlaneStrain = function_symmetric_gradient(cellvalues_u, q_point, ue)
            ‚àáÀ¢u = SymmetricTensor{2,3,Float64}((Œµ_PlaneStrain[1, 1], Œµ_PlaneStrain[1, 2], 0.0,Œµ_PlaneStrain[2, 2], 0.0, 0.0))
        elseif material.dim == 3
            ‚àáÀ¢u = function_symmetric_gradient(cellvalues_u, q_point, ue)
        else
            error("Invalid element dimension")
        end

        œï = state[q_point].œï
        gd, gd‚Ä≤, gd‚Ä≤‚Ä≤  = Degradation(œï, material);
        Œ®‚Å∫, D·µâ, œÉ, œÉ‚Å∫ = Constitutive(‚àáÀ¢u, material, gd);
        H = max(Œ®‚Å∫, state_old[q_point].H);
        #state[q_point] = HistoryVariable(H, œï);

        for i in 1:nbase_u
            if material.dim == 2
                Œ¥Œµ_2d = shape_symmetric_gradient(cellvalues_u, q_point, i);
                Œ¥Œµ = SymmetricTensor{2,3,Float64}((Œ¥Œµ_2d[1, 1], Œ¥Œµ_2d[1, 2], 0.0,Œ¥Œµ_2d[2, 2], 0.0, 0.0));
            else
                Œ¥Œµ = shape_symmetric_gradient(cellvalues_u, q_point, i);
            end
            for j in 1:nbase_u
                if material.dim == 2
                    Œµ_2d = shape_symmetric_gradient(cellvalues_u, q_point, j);
                    ŒµÃÑu = SymmetricTensor{2,3,Float64}((Œµ_2d[1, 1], Œµ_2d[1, 2], 0.0,
                        Œµ_2d[2, 2], 0.0, 0.0));
                else
                    ŒµÃÑu = shape_symmetric_gradient(cellvalues_u, q_point, j);
                end
                Ke[BlockIndex((u‚ñÑ, u‚ñÑ), (i, j))] += Œ¥Œµ ‚ä° D·µâ ‚ä° ŒµÃÑu * dŒ©·µ§  #Œµ ÊòØ B and Œ¥Œµ ÊòØ B·µÄ ÊïÖ B·µÄDB
            end
            for j in 1:nbase_œï
                œï‚Ä≤ = shape_value(cellvalues_œï, q_point, j)
                Ke[BlockIndex((u‚ñÑ, œï‚ñÑ), (i, j))] += (gd‚Ä≤ * Œ¥Œµ ‚ä° œÉ‚Å∫ * œï‚Ä≤) * dŒ©·µ§
            end
        end
        for i in 1:nbase_œï
            Œ¥œï = shape_value(cellvalues_œï, q_point, i)
            ‚àáŒ¥œï = shape_gradient(cellvalues_œï, q_point, i)
            for j in 1:nbase_œï
                œï‚Ä≤ = shape_value(cellvalues_œï, q_point, j)
                ‚àáœï‚Ä≤ = shape_gradient(cellvalues_œï, q_point, j)
                Ke[BlockIndex((œï‚ñÑ, œï‚ñÑ), (i, j))] += (gd‚Ä≤‚Ä≤ * œï‚Ä≤ * H * Œ¥œï + Gc / ‚Ñì *Œ¥œï * œï‚Ä≤ +  Gc *‚Ñì * ‚àáŒ¥œï ‚ãÖ ‚àáœï‚Ä≤) * dŒ©·µ§
            end
            for j in 1:nbase_u
                if material.dim == 2
                    Œµ_2d = shape_symmetric_gradient(cellvalues_u, q_point, j);
                    ŒµÃÑu = SymmetricTensor{2,3,Float64}((Œµ_2d[1, 1], Œµ_2d[1, 2], 0.0,
                        Œµ_2d[2, 2], 0.0, 0.0));
                else
                    ŒµÃÑu = shape_symmetric_gradient(cellvalues_u, q_point, j);
                end
                if state[q_point].H > state_old[q_point].H
                    Ke[BlockIndex((œï‚ñÑ, u‚ñÑ), (i, j))] += (gd‚Ä≤ *Œ¥œï * œÉ‚Å∫ ‚ä° ŒµÃÑu) * dŒ©·µ§
                else
                    Ke[BlockIndex((œï‚ñÑ, u‚ñÑ), (i, j))] += 0.0
                end   
            end
        end
    end    
end

function closure_M(K_uu, K_œïœï, K_uœï, K_œïu, x)
    result = x - K_uu\(K_uœï*(K_œïœï\(K_œïu*x)));
    return result
end

function cal_rho1(K_uu, K_œïœï, K_uœï, K_œïu)
    n = size(K_uu, 1) 
    m = size(K_œïœï, 1) 
    A = [spzeros(Float64, n, n)  -K_uœï;
                spzeros(Float64, m, n)  spzeros(Float64, m, m)]
    B = [K_uu                     spzeros(Float64, n, m);
                K_œïu                     K_œïœï]
    rho = eigs(sparse(A), sparse(B); nev=1, which=:LM, tol=1e-2)[1] 
    rho = abs(rho[1]) 
    return Float64(rho)
end

# Êà™Êñ≠ÂáΩÊï∞Ôºö‰øùÁïôÂâç k ‰∏™ÊúÄÂ§ßÁöÑÂÖÉÁ¥†
function truncate_vector(x, k)
    # Á°Æ‰øù k ÊòØÊï¥Êï∞
    k = Int(round(k))
    
    # Ëé∑ÂèñÁªùÂØπÂÄºÊúÄÂ§ßÁöÑ k ‰∏™ÂÖÉÁ¥†ÁöÑÁ¥¢Âºï
    idx = sortperm(abs.(x), rev=true)[1:k]
    
    # ÂàõÂª∫‰∏Ä‰∏™Êñ∞ÁöÑÂêëÈáèÔºåÂè™‰øùÁïôÂâç k ‰∏™ÊúÄÂ§ßÁöÑÂÖÉÁ¥†ÔºåÂÖ∂‰ΩôÁΩÆÈõ∂
    truncated_x = zeros(length(x))
    truncated_x[idx] = x[idx]
    return truncated_x
end


function gmres_user( K11, K22, K12, K21, b::Vector{Float64}; max_iter::Int=50, tol::Float64=1e-6)::Vector{Float64}
    n = length(b)
    x0 = zeros(Float64, n) 
    x_solution = copy(x0) 
    r0_vec = copy(b) 
    Œ≤ = norm(r0_vec)

    V_basis = zeros(Float64, n, max_iter + 1)
    H_hessenberg = zeros(Float64, max_iter + 1, max_iter)
    g_rhs = zeros(Float64, max_iter + 1)    
    
    cs_givens = zeros(Float64, max_iter) 
    sn_givens = zeros(Float64, max_iter) 
    
    axpy!(1.0 / Œ≤, r0_vec, @view V_basis[:, 1]) # V_basis[:,1] = r0_vec / Œ≤
    g_rhs[1] = Œ≤

    j_actual_iters = 0 
    @inbounds begin
    for j in 1:max_iter 
        j_actual_iters = j
        current_V_j_view = @view V_basis[:, j]
        w = closure_M(K11, K22, K12, K21, current_V_j_view)

        # --- Ê≠£‰∫§Âåñ: Modified Gram-Schmidt (MGS) ---
        for i in 1:j
            V_i_view = @view V_basis[:,i]
            h_coeff = dot(V_i_view, w) 
            H_hessenberg[i, j] = h_coeff 
            axpy!(-h_coeff, V_i_view, w) 
        end
        # --- MGS ÁªìÊùü ---
        
        H_hessenberg[j+1, j] = norm(w)

        if H_hessenberg[j+1, j] < eps(Float64) * Œ≤ 
            break 
        end
        
        rmul!(w, 1.0 / H_hessenberg[j+1, j]) 
        (@view V_basis[:, j+1]) .= w   

        for i_rot in 1:(j-1)
            h_i_j_curr = H_hessenberg[i_rot, j]
            h_ip1_j_curr = H_hessenberg[i_rot+1, j]
            cs_val = cs_givens[i_rot]
            sn_val = sn_givens[i_rot]
            H_hessenberg[i_rot, j]   = cs_val * h_i_j_curr + sn_val * h_ip1_j_curr
            H_hessenberg[i_rot+1, j] = -sn_val * h_i_j_curr + cs_val * h_ip1_j_curr
        end
        
        a_rot = H_hessenberg[j,j]
        b_rot = H_hessenberg[j+1,j]
        
        local current_c, current_s
        rho_rot = sqrt(a_rot^2 + b_rot^2) 
        if rho_rot != 0.0 
            current_c = a_rot / rho_rot
            current_s = b_rot / rho_rot
            H_hessenberg[j,j] = rho_rot
            H_hessenberg[j+1,j] = 0.0 
        else
            current_c = 1.0
            current_s = 0.0
        end
        cs_givens[j] = current_c
        sn_givens[j] = current_s
        
        g_rhs[j+1] = -current_s * g_rhs[j] 
        g_rhs[j]   =  current_c * g_rhs[j] 

        relres = abs(g_rhs[j+1]) / Œ≤

        if relres < tol
            println("Á¨¨ $j Ê¨°Ëø≠‰ª£Êî∂ÊïõÔºåÁõ∏ÂØπÊÆãÂ∑Æ‰∏∫ $relres")
            break
        end
    end
    end # @inbounds end
    if j_actual_iters == 0
        if Œ≤ < tol return x_solution end
        return x_solution 
    end
    
    H_solve_view = @view H_hessenberg[1:j_actual_iters, 1:j_actual_iters]
    g_solve_view = @view g_rhs[1:j_actual_iters]
    
    y_solution = UpperTriangular(H_solve_view) \ g_solve_view

    mul!(x_solution, (@view V_basis[:, 1:j_actual_iters]), y_solution, 1.0, 0.0)
    return x_solution
end

function assemble_global_K_old(q, K, cellvalues_u,cellvalues_œï, dh, material, states, states_old)

    assembler = start_assemble(K)
    nu = getnbasefunctions(cellvalues_u)
    nœï = getnbasefunctions(cellvalues_œï)

    Ke = BlockArray(zeros(nu + nœï, nu + nœï), [nu, nœï], [nu, nœï]) # local stiffness matrix
    for (i, cell)  in enumerate(CellIterator(dh))
        fill!(Ke, 0)
        reinit!(cellvalues_œï, cell);
        reinit!(cellvalues_u, cell);
        eldofs = celldofs(cell)
        qe = q[eldofs]
        state = @view states[:, i]
        state_old = @view states_old[:, i]
        assemble_element_ke_old!(Ke, cell, cellvalues_u, cellvalues_œï, qe, material, state, state_old)

        assemble!(assembler, eldofs, Ke)
    end
    return K
end

function OutputForce(u, cellvalues_u, dh_u, grid, material, states, states_old, set::String, tag)
	F = assemble_global_r(u, cellvalues_u, dh_u, material, states, states_old, tag, true);
	F_x = 0.0;
	F_y = 0.0;
	Fnodal = reshape_to_nodes(dh_u, F, :u);
    # Fnodal = evaluate_at_grid_nodes(dh, F, :u);
	if set ‚àà keys(grid.nodesets);
		outputset = grid.nodesets[set];
	elseif set ‚àà keys(grid.facesets[set]);
		print("facesets are currently not supported for force output");
	else;
		print("Warning invalid set for force output");
	end;
	for (i, n) in enumerate(grid.nodesets[set]);
		F_x += Fnodal[1, n];
		F_y += Fnodal[2, n];
		# F_x += Fnodal[i][1];
		# F_y += Fnodal[i][2];
	end;
	return F_x, F_y;
end;
function CrackTrack(q, dh, cellValues, grid, a0, CrackDir)
	Ac = a0
	v = CrackDir
	for (i, cell) in enumerate(CellIterator(dh))
		reinit!(cellValues, cell)
		eldofs = celldofs(cell)
		œïe = q[eldofs]
		if maximum(œïe) >= 0.95
			node_coords = getcoordinates(grid, i)
			for q_point in 1:getnquadpoints(cellValues)
				#Phase field value
				œï = function_value(cellValues, q_point, œïe)
				if œï >= 0.95
					coords = spatial_coordinate(cellValues, q_point, node_coords)
					Ac = coords[v] > Ac ? coords[v] : Ac
				end
			end
		end
	end
	return Ac
end
function write_to_txt(filename, variable)
    open(filename, "w") do file
        write(file, string(variable))  # Â∞ÜÂèòÈáèËΩ¨Êç¢‰∏∫Â≠óÁ¨¶‰∏≤ÂÜôÂÖ•Êñá‰ª∂
    end
end
function save_results(folder, timestep, u, œï, states, states_old)
    # Á°Æ‰øùÊñá‰ª∂Â§πÂ≠òÂú®ÔºåÂ¶ÇÊûú‰∏çÂ≠òÂú®ÂàôÂàõÂª∫
    if !isdir(folder)
        mkdir(folder)
    end

    # Â∞ÜÊó∂Èó¥Ê≠•Ê†ºÂºèÂåñ‰∏∫Â≠óÁ¨¶‰∏≤Ôºå‰øùÁïô 5 ‰ΩçÂ∞èÊï∞ÔºåÂπ∂Áî®‰∏ãÂàíÁ∫øÊõø‰ª£Â∞èÊï∞ÁÇπ
    timestep_str = replace(@sprintf("%.5f", timestep), "." => "_")
    filename = joinpath(folder, "time_$timestep_str.jld")  # Â∞ÜÊñá‰ª∂‰øùÂ≠òÂà∞ÊåáÂÆöÊñá‰ª∂Â§π
    save(filename, "timestep", timestep, "u", u, "œï", œï, "states", states, "states_old", states_old)
end
function load_results(folder, timestep)
    # Â∞ÜÊó∂Èó¥Ê≠•Ê†ºÂºèÂåñ‰∏∫Â≠óÁ¨¶‰∏≤Ôºå‰øùÁïô 5 ‰ΩçÂ∞èÊï∞ÔºåÂπ∂Áî®‰∏ãÂàíÁ∫øÊõø‰ª£Â∞èÊï∞ÁÇπ
    timestep_str = replace(@sprintf("%.5f", timestep), "." => "_")
    filename = joinpath(folder, "time_$timestep_str.jld")  # ‰ªéÊåáÂÆöÊñá‰ª∂Â§πÂä†ËΩΩÊñá‰ª∂
    if !isfile(filename)
        error("File $filename does not exist.")
    end
    data = load(filename)
    return data["timestep"], data["u"], data["œï"], data["states"], data["states_old"]
end

function updatePsi(cellvalues_u, u, dh_u, material, states, states_old)
    for (i, cell) in enumerate(CellIterator(dh_u))
        reinit!(cellvalues_u, cell)
        eldofs_u = celldofs(cell)         # ÈíàÂØπdh_uÔºåÁºñÂè∑Â∞±ÊòØuÂú∫ÁöÑÊú¨Âú∞ÁºñÂè∑
        ue = u[eldofs_u]
        state = @view states[:, i]
        state_old = @view states_old[:, i]
        states[:, i] = assemble_element_psi!(cellvalues_u, ue, material, state, state_old)
    end
    return states
end

function assemble_element_psi!(cellvalues_u,ue::Vector, material::Material, state, state_old)
    for q_point in 1:getnquadpoints(cellvalues_u)
        œï = state[q_point].œï;
        if material.dim == 2
            Œµ_PlaneStrain = function_symmetric_gradient(cellvalues_u, q_point, ue);
            ‚àáÀ¢u = SymmetricTensor{2,3,Float64}((Œµ_PlaneStrain[1, 1], Œµ_PlaneStrain[1, 2], 0.0, Œµ_PlaneStrain[2, 2], 0.0, 0.0));
        elseif material.dim == 3
            ‚àáÀ¢u = function_symmetric_gradient(cellvalues_u, q_point, ue) - ŒµŒ∏*one(SymmetricTensor{2, 3});
        else
            error("Invalid element dimension");
        end
        
        gd, _, _ = Degradation(œï, material);
        Œ®‚Å∫, _, œÉ, _ = Constitutive(‚àáÀ¢u, material, gd);
        H = max(Œ®‚Å∫, state_old[q_point].H);
        state[q_point] = HistoryVariable(H, œï);
    end
    return state
end
