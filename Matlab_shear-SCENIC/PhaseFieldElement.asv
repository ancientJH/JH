function [r_e, k_e] = PhaseFieldElement(localCoord, localSol, ElementType, ...
    constitutive, body_force, current_load_step, nQuad, ielem, Psi_plus_rec, Psi_plus_old, which_half)%把一个单元的参数传进来
if (nargin < 15)
    switch ElementType
        case 'P12D'
            nQuad = 3; nQuadBdry = 2;%有三个边，每个边有两个点
        case 'Q12D'
            nQuad = 4; nQuadBdry = 2;
    end
end
% global Psi_plus_rec Psi_plus_old
[xi, w] = GetQuadratureRule(ElementType, nQuad);
nDim = size(localCoord, 1);%二维问题
nDoF = nDim + 1;%每个节点有三个量：两个位移+1个d
nNodesElement = size(localCoord, 2);

d_DoFs = nDoF * (1:nNodesElement)';
u_DoFs = true(length(localSol), 1);
u_DoFs(d_DoFs) = false;

switch nDim
    case 1
        [detJ, Na, dNa_dx] = QuadShape(ElementType, localCoord, xi);
    case 2
        [detJ, Na, dNa_dx, dNa_dy] = QuadShape(ElementType, localCoord, xi);
    case 3
        [detJ, Na, dNa_dx, dNa_dy, dNa_dz] = QuadShape(ElementType, localCoord, xi);
end

if which_half == 'Ru'
    r_e_u = zeros(nDim*nNodesElement, 1);
elseif which_half == 'Rd'
    r_e_d = zeros(nNodesElement, 1);
    %crack_length = zeros(nNodesElement, 1);
elseif which_half == 'K'
    k_e_uu = zeros(length(r_e_u));
    k_e_dd = zeros(length(r_e_d));
    k_e_ud = zeros(length(r_e_u), length(r_e_d));%还有ud?
    k_e_du = zeros(length(r_e_d), length(r_e_u));%还有ud?
elseif which_half == 'Kuu'
    k_e_uu = zeros(length(r_e_u));
elseif which_half == 'Kdd'
    k_e_dd = zeros(length(r_e_d));
end

zero_filler = zeros(1, length(dNa_dx));
for iQuad = 1:nQuad
    switch nDim
        case 1
            B = dNa_dx(:,iQuad);
            Bd = B;
        case 2
            B = [reshape([dNa_dx(:,iQuad)'; zero_filler], 1, [])
                reshape([zero_filler; dNa_dy(:,iQuad)'], 1, [])
                reshape([dNa_dy(:,iQuad)'; dNa_dx(:,iQuad)'], 1, [])];%为什么要这样组合？
            Bd = [dNa_dx(:,iQuad)'; dNa_dy(:,iQuad)'];%为什么要这样组合？
        case 3
            B = [reshape([dNa_dx(:,iQuad)'; zero_filler; zero_filler], 1, [])
                reshape([zero_filler; dNa_dy(:,iQuad)'; zero_filler], 1, [])
                reshape([zero_filler; zero_filler; dNa_dz(:,iQuad)'], 1, [])
                reshape([zero_filler; dNa_dz(:,iQuad)'; dNa_dy(:,iQuad)'], 1, [])
                reshape([dNa_dz(:,iQuad)'; zero_filler; dNa_dx(:,iQuad)'], 1, [])
                reshape([dNa_dy(:,iQuad)'; dNa_dx(:,iQuad)'; zero_filler], 1, [])];
            Bd = [dNa_dx(:,iQuad)'; dNa_dy(:,iQuad)'; dNa_dz(:,iQuad)'];
    end

    if which_half == 'Ru'
        StrainVector = B * localSol(u_DoFs);%应力
        [StressVector, D, ~, sigma_plus, gc, ell] = constitutive(StrainVector, d);%出来相场的东西
        BodyForces = current_load_step * body_force(localCoord*Na(:,iQuad));
        r_e_u = r_e_u + (B' * StressVector - reshape(BodyForces * Na(:,iQuad)', [], 1)) ...
            * w(iQuad) * detJ(iQuad);
    elseif which_half == 'Rd'
        StrainVector = B * localSol(u_DoFs);%应力
        d = localSol(d_DoFs)' * Na(:,iQuad);
        [~, ~, ~, ~, gc, ell] = constitutive(StrainVector, d);
        grad_d = Bd * localSol(d_DoFs);
        Psi_plus_new =  Psi_plus_rec(iQuad,ielem);
        r_e_d = r_e_d + (- 2 * (1-d) * Na(:,iQuad) * Psi_plus_new + gc * (d * Na(:,iQuad) / ell ...
            + ell * Bd' * grad_d)) ...
            * w(iQuad) * detJ(iQuad);%修改前
    elseif which_half == 'K'
        StrainVector = B * localSol(u_DoFs);%应力
        d = localSol(d_DoFs)' * Na(:,iQuad);
        %grad_d = Bd * localSol(d_DoFs);
        [~, D, ~, sigma_plus, gc, ell] = constitutive(StrainVector, d);%出来相场的东西
        %BodyForces = current_load_step * body_force(localCoord*Na(:,iQuad));%应该是要转化为高斯点 修改前 两个方向的bodyforce,施加在了高斯点上
        k_e_uu = k_e_uu + B' * D * B * w(iQuad) * detJ(iQuad);
        k_e_dd = k_e_dd + (Na(:,iQuad) * (2 * Psi_plus_new + gc / ell) * Na(:,iQuad)' ...
            + Bd' * gc * ell * Bd) ...
            * w(iQuad) * detJ(iQuad);%修改前
        k_e_ud = k_e_ud - 2 * B' * (1-d) * sigma_plus * Na(:,iQuad)' ...
            * w(iQuad) * detJ(iQuad);%论文中的Cap  修改前
        if Psi_plus_rec(iQuad,ielem)>Psi_plus_old(iQuad,ielem)
            k_e_du = k_e_du - (2 * B' * (1-d) *  sigma_plus * Na(:,iQuad)')' ...
                * w(iQuad) * detJ(iQuad);
        end
    elseif which_half == 'Kuu'
        StrainVector = B * localSol(u_DoFs);%应力
        d = localSol(d_DoFs)' * Na(:,iQuad);
        %grad_d = Bd * localSol(d_DoFs);
        [~, D, ~, ~, ~, ~] = constitutive(StrainVector, d);%出来相场的东西
        k_e_uu = k_e_uu + B' * D * B * w(iQuad) * detJ(iQuad);
    elseif which_half == 'Kdd'
        StrainVector = B * localSol(u_DoFs);%应力
        d = localSol(d_DoFs)' * Na(:,iQuad);
        [~, ~, ~, ~, gc, ell] = constitutive(StrainVector, d);
        Psi_plus_new =  Psi_plus_rec(iQuad,ielem);
        k_e_dd = k_e_dd + (Na(:,iQuad) * (2 * Psi_plus_new + gc / ell) * Na(:,iQuad)' ...
            + Bd' * gc * ell * Bd) ...
            * w(iQuad) * detJ(iQuad);%修改前
    end

    if which_half == 'u'
        StrainVector = B * localSol(u_DoFs);%应力
        [StressVector, D, Psi_plus, sigma_plus, gc, ell] = constitutive(StrainVector, d);%出来相场的东西
        BodyForces = current_load_step * body_force(localCoord*Na(:,iQuad));%应该是要转化为高斯点 修改前 两个方向的bodyforce,施加在了高斯点上
        %BodyForces = current_load_step * body_force(Coord);%修改后
        Psi_plus_rec(iQuad,ielem) = max(Psi_plus_old(iQuad,ielem),Psi_plus);
        Psi_plus_new =  Psi_plus_rec(iQuad,ielem);
        r_e_u = r_e_u + (B' * StressVector - reshape(BodyForces * Na(:,iQuad)', [], 1)) ...
            * w(iQuad) * detJ(iQuad);
    elseif which_half == 'd'
        d = localSol(d_DoFs)' * Na(:,iQuad);
        [~, ~, ~, ~, gc, ~] = constitutive(StrainVector, d);
        grad_d = Bd * localSol(d_DoFs);
        
        r_e_d = r_e_d + (- 2 * (1-d) * Na(:,iQuad) * Psi_plus_new + gc * (d * Na(:,iQuad) / ell ...
        + ell * Bd' * grad_d)) ...
        * w(iQuad) * detJ(iQuad);%修改前
    end
    

    if nargout > 1
        k_e_uu = k_e_uu + B' * D * B * w(iQuad) * detJ(iQuad);
        k_e_dd = k_e_dd + (Na(:,iQuad) * (2 * Psi_plus_new + gc / ell) * Na(:,iQuad)' ...
            + Bd' * gc * ell * Bd) ...
            * w(iQuad) * detJ(iQuad);%修改前
        k_e_ud = k_e_ud - 2 * B' * (1-d) * sigma_plus * Na(:,iQuad)' ...
            * w(iQuad) * detJ(iQuad);%论文中的Cap  修改前
        if Psi_plus_rec(iQuad,ielem)>Psi_plus_old(iQuad,ielem)
            k_e_du = k_e_du - (2 * B' * (1-d) *  sigma_plus * Na(:,iQuad)')' ...
                * w(iQuad) * detJ(iQuad);
        end
    end
    %crack_length(iQuad) = ((d * d / (2 * ell) ...
     %   + ell / 2 * (grad_d' * grad_d))) ...
     %   * w(iQuad) * detJ(iQuad);

end

switch ElementType
    case 'P12D'
        nFaces = 3;
        FaceNodes = [1, 2, 3
            2, 3, 1];
        FaceElementType = 'P11D';
    case 'Q12D'
        nFaces = 4;
        FaceNodes = [1, 2, 3, 4
            2, 3, 4, 1];
        FaceElementType = 'P11D';
    case 'P13D'
        nFaces = 4;
        FaceNodes = [1, 1, 1, 2
            3, 2, 4, 3
            2, 4, 3, 4];
end

% Compute the contribution of the traction to the residual.
[xi, w] = GetQuadratureRule(FaceElementType, nQuadBdry);
for iFace = 1:nFaces
    ThisFaceNodes = FaceNodes(:, iFace);
    FaceCoord = localCoord(:, ThisFaceNodes);
    element_uDoFs = reshape(repmat(ThisFaceNodes'-1, nDim, 1) * nDim + repmat((1:nDim)', 1, length(ThisFaceNodes)), [], 1);
    [detJ, Na] = FaceQuadShape(FaceElementType, FaceCoord, xi);
    for iQuadBdry = 1:nQuadBdry
%         TractionThisPoint = current_load_step * traction(FaceCoord *
%         Na(:, iQuadBdry));修改前
%TractionThisPoint = current_load_step * traction(FaceCoord * Na(:, iQuadBdry),localCoord);
 TractionThisPoint = [0;0];
        r_e_u(element_uDoFs) = r_e_u(element_uDoFs) - reshape(TractionThisPoint * Na(:, iQuadBdry)', [], 1) ...
            * w(iQuadBdry) * detJ(iQuadBdry);
    end
end

r_e = zeros(length(localSol), 1);
%crack_r = zeros(length(localSol), 1);
r_e(u_DoFs) = r_e_u;
r_e(d_DoFs) = r_e_d;
%crack_r(d_DoFs) =  crack_length;

k_e = zeros(length(localSol), length(localSol));
k_e(u_DoFs, u_DoFs) = k_e_uu;
k_e(d_DoFs, d_DoFs) = k_e_dd;
k_e(u_DoFs, d_DoFs) = k_e_ud;
k_e(d_DoFs, u_DoFs) = k_e_du;