#ÂÆö‰πâÊùêÊñôÂèÇÊï∞Áõ∏ÂÖ≥ÁöÑÁªìÊûÑ‰Ωì
struct Material{T}
    E::T  # Young's modulus
    G::T  # Shear modulus = Œº (Lame constant)
    K::T  # Bulk modulus
    Œª::T  # Lame constant
    ŒΩ::T  # Poisson's ratio
    Gc::T # Fracture Toughness
    œÉc::T # Strength
    ‚Ñì::T  # Phase field length scale
    s::T  # parameter for Hughes degradation 
    a‚ÇÅ::T # parameter for Wu degradation 
    flag::StrainDecomp
    flagD::DegradType
    dim::Int64
end
function Material(E, ŒΩ, Gc, œÉc, ‚Ñì, s, flag, flagD, dim)
    G = E / 2(1 + ŒΩ);
    K = E / 3(1 - 2ŒΩ);
    Œª = K - 2G / 3;
    a‚ÇÅ = 27E*Gc/(128œÉc^2*‚Ñì‚ÇÄ);
    return Material(E, G, K, Œª, ŒΩ, Gc, œÉc, ‚Ñì, s, a‚ÇÅ, flag, flagD, dim)
end

#ÂÆö‰πâÂéÜÂè≤ÂèòÈáèÁªìÊûÑ‰Ωì
struct HistoryVariable{T}
	H::T # History variable
	œï::T #phase field variable from last increment
end
function HistoryVariable()
	return HistoryVariable(0.0, 0.0)
end
#ÂÆö‰πâÊ±ÇËß£ÂèÇÊï∞ÁªìÊûÑ‰Ωì
mutable struct SolverState{T,F}
    loadsteps::Vector{F}
    nitr_inner::T
    nitr_outer::T
    TOL_u::F
    TOL_œï::F
end
function create_solver_state(loadsteps, nitr_inner, nitr_outer, TOL_u, TOL_œï)
    return SolverState(loadsteps, nitr_inner, nitr_outer, TOL_u, TOL_œï)
end
#ÂÆö‰πâËæìÂá∫ÂèÇÊï∞ÁªìÊûÑ‰Ωì
mutable struct OutputVariables{T}
    plotframe::T
    totalIterations_outer::T
    totalIterations_œï::T
    totalIterations_u::T
    plotFrequency::T
    historyFrequency::T
    a0::Float64
    CrackDir::T
    OutputSet::String
end
#ËæìÂá∫ÂèÇÊï∞ÁªìÊûÑ‰ΩìÁöÑÂàùÂßãÂåñ
function OutputVariables(field_frequency, history_frequency, a0, CrackDir, outputset)
    return OutputVariables(0, 0, 0, 0, field_frequency, history_frequency, a0, CrackDir, outputset)
end

function assemble_element_u!(Ke, Re, cellvalues_u, ue, material, state, state_old)
    nbase_u = getnbasefunctions(cellvalues_u);
    for q_point in 1:getnquadpoints(cellvalues_u)
        dŒ©·µ§ = getdetJdV(cellvalues_u, q_point)
        if material.dim == 2
            Œµ_PlaneStrain = function_symmetric_gradient(cellvalues_u, q_point, ue)
            ‚àáÀ¢u = SymmetricTensor{2,3,Float64}((Œµ_PlaneStrain[1, 1], Œµ_PlaneStrain[1, 2], 0.0,Œµ_PlaneStrain[2, 2], 0.0, 0.0))
        elseif material.dim == 3
            ‚àáÀ¢u = function_symmetric_gradient(cellvalues_u, q_point, ue)
        else
            error("Invalid element dimension")
        end

        œï = state[q_point].œï
        gd, _, _ = Degradation(œï, material);
        Œ®‚Å∫, D·µâ, œÉ = Constitutive(‚àáÀ¢u, material, gd);
        H = max(Œ®‚Å∫, state_old[q_point].H);
        state[q_point] = HistoryVariable(H, œï);

        for i in 1:nbase_u
            if material.dim == 2
                Œ¥Œµ_2d = shape_symmetric_gradient(cellvalues_u, q_point, i);
                Œ¥Œµ = SymmetricTensor{2,3,Float64}((Œ¥Œµ_2d[1, 1], Œ¥Œµ_2d[1, 2], 0.0,Œ¥Œµ_2d[2, 2], 0.0, 0.0));
            else
                Œ¥Œµ = shape_symmetric_gradient(cellvalues_u, q_point, i);
            end
            for j in 1:i
                if material.dim == 2
                    Œµ_2d = shape_symmetric_gradient(cellvalues_u, q_point, j);
                    ŒµÃÑu = SymmetricTensor{2,3,Float64}((Œµ_2d[1, 1], Œµ_2d[1, 2], 0.0,
                        Œµ_2d[2, 2], 0.0, 0.0));
                else
                    ŒµÃÑu = shape_symmetric_gradient(cellvalues_u, q_point, j);
                end
                Ke[i, j] += Œ¥Œµ ‚ä° D·µâ ‚ä° ŒµÃÑu * dŒ©·µ§;
            end
            Re[i] += Œ¥Œµ ‚ä° œÉ * dŒ©·µ§;
        end
    end
    symmetrize_lower!(Ke)
    return Ke, Re
end

function assemble_residual_u!(Re::Vector, cellvalues_u,ue::Vector, material::Material, state, state_old, store::Bool)
    nbase_u = getnbasefunctions(cellvalues_u);
    for q_point in 1:getnquadpoints(cellvalues_u)
        dŒ©·µ§ = getdetJdV(cellvalues_u, q_point);
        œï = state[q_point].œï;
        if material.dim == 2
            Œµ_PlaneStrain = function_symmetric_gradient(cellvalues_u, q_point, ue);
            ‚àáÀ¢u = SymmetricTensor{2,3,Float64}((Œµ_PlaneStrain[1, 1], Œµ_PlaneStrain[1, 2], 0.0, Œµ_PlaneStrain[2, 2], 0.0, 0.0));
        elseif material.dim == 3
            ‚àáÀ¢u = function_symmetric_gradient(cellvalues_u, q_point, ue);
        else
            error("Invalid element dimension");
        end
        
        gd, _, _ = Degradation(œï, material);
        Œ®‚Å∫, _, œÉ, _ = Constitutive(‚àáÀ¢u, material, gd);
        H = max(Œ®‚Å∫, state_old[q_point].H);
        if store
            state[q_point] = HistoryVariable(H, œï);
        end
        for i in 1:nbase_u
            if material.dim == 2
                Œ¥Œµ_2d = shape_symmetric_gradient(cellvalues_u, q_point, i);
                Œ¥Œµ = SymmetricTensor{2,3,Float64}((Œ¥Œµ_2d[1, 1], Œ¥Œµ_2d[1, 2], 0.0, Œ¥Œµ_2d[2, 2], 0.0, 0.0));
            else
                Œ¥Œµ = shape_symmetric_gradient(cellvalues_u, q_point, i);
            end
            Re[i] += (Œ¥Œµ ‚ä° œÉ) * dŒ©·µ§;
        end
    end
    return Re
end

function assemble_element_œï!(Ke::Matrix, Re::Vector, cellvalues_œï, œïe::Vector, material::Material, state, state_old)
    nbase_œï = getnbasefunctions(cellvalues_œï);
    Gc = material.Gc;
    ‚Ñì = material.‚Ñì;
    for q_point in 1:getnquadpoints(cellvalues_œï)
        dŒ©·µ© = getdetJdV(cellvalues_œï, q_point);
        œï = function_value(cellvalues_œï, q_point, œïe);
        ‚àáœï = function_gradient(cellvalues_œï, q_point, œïe);

        H = state[q_point].H;
        state[q_point] = HistoryVariable(H, œï);
        _, gd‚Ä≤, gd‚Ä≤‚Ä≤ = Degradation(œï, material);
        for i in 1:nbase_œï
            Œ¥œï = shape_value(cellvalues_œï, q_point, i);
            ‚àáŒ¥œï = shape_gradient(cellvalues_œï, q_point, i);
            for j in 1:i
                œï‚Ä≤ = shape_value(cellvalues_œï, q_point, j);
                ‚àáœï‚Ä≤ = shape_gradient(cellvalues_œï, q_point, j);
                Ke[i, j] += (gd‚Ä≤‚Ä≤ * œï‚Ä≤ * H * Œ¥œï + Gc / ‚Ñì * Œ¥œï * œï‚Ä≤ + Gc * ‚Ñì * ‚àáŒ¥œï ‚ãÖ ‚àáœï‚Ä≤) * dŒ©·µ©;
            end
            Re[i] += (gd‚Ä≤ * H * Œ¥œï + Gc / ‚Ñì * Œ¥œï * œï + Gc * ‚Ñì * ‚àáŒ¥œï ‚ãÖ ‚àáœï) * dŒ©·µ©;
        end
    end
    symmetrize_lower!(Ke)
    return Ke, Re
end

function assemble_residual_œï!(Re::Vector, cellvalues_œï, œïe::Vector, material::Material, state, state_old, store::Bool)
    nbase_œï = getnbasefunctions(cellvalues_œï);
    Gc = material.Gc;
    ‚Ñì = material.‚Ñì;
    for q_point in 1:getnquadpoints(cellvalues_œï);
        dŒ©·µ© = getdetJdV(cellvalues_œï, q_point);
        œï = function_value(cellvalues_œï, q_point, œïe);
        ‚àáœï = function_gradient(cellvalues_œï, q_point, œïe);
        H = state[q_point].H;
        if store
            state[q_point] = HistoryVariable(H, œï);
        end       
        _, gd‚Ä≤, _ = Degradation(œï, material);
        for i in 1:nbase_œï
            Œ¥œï = shape_value(cellvalues_œï, q_point, i);
            ‚àáŒ¥œï = shape_gradient(cellvalues_œï, q_point, i);
            Re[i] += (gd‚Ä≤ * H * Œ¥œï +  Gc / ‚Ñì * Œ¥œï * œï +  Gc * ‚Ñì * ‚àáŒ¥œï ‚ãÖ ‚àáœï) * dŒ©·µ©;
        end
    end
    return Re
end

function symmetrize_lower!(K)
    for i in 1:size(K,1)
        for j in i+1:size(K,1)
            K[i,j] = K[j,i]
        end
    end
end


function assemble_global_r(q::Vector, cellvalues, dh::DofHandler, material::Material, states, states_old, tag::String, store::Bool=true)
    nbase = getnbasefunctions(cellvalues);
    Re = zeros(nbase);
    R = zeros(ndofs(dh));
    for (i, cell) in enumerate(CellIterator(dh))
        reinit!(cellvalues, cell);
        fill!(Re, 0);
        eldofs = celldofs(cell);
        qe = q[eldofs];
        state = @view states[:, i];
        state_old = @view states_old[:, i];
        if tag == "u"
            assemble_residual_u!(Re, cellvalues, qe, material, state, state_old, store);
        elseif tag == "œï"
            assemble_residual_œï!(Re, cellvalues, qe, material, state, state_old, store);
        end
        R[eldofs] += Re;
    end
    return R
end;

function CreatCellvalues(ElementShape, ElementOrder, QuadratureOrder, dim)
	ip = Lagrange{dim, ElementShape, ElementOrder}()
	qr = QuadratureRule{dim, ElementShape}(QuadratureOrder)
	cellvalues_u = CellVectorValues(qr, ip)
	cellvalues_œï = CellScalarValues(qr, ip)
	return ip, qr, cellvalues_u, cellvalues_œï
end

function CreatBC(grid, dim)
	dbc‚ÇÅ = Dirichlet(:u, getfaceset(grid, "top"), (x, t) -> t, 2)
	dbc‚ÇÇ = Dirichlet(:u, getfaceset(grid, "bottom"), (x, t) -> [0, 0], [1, 2])

	dh_u = DofHandler(grid)
	add!(dh_u, :u, dim) 
	close!(dh_u)

	bch_u = ConstraintHandler(dh_u)
	add!(bch_u, dbc‚ÇÅ)
	add!(bch_u, dbc‚ÇÇ) 
	close!(bch_u)
	update!(bch_u, 0.0)

	dh_œï = DofHandler(grid)
	add!(dh_œï, :œï, 1) 
	close!(dh_œï)

	bch_œï = ConstraintHandler(dh_œï) 
	close!(bch_œï)
	update!(bch_œï, 0.0)

    return dh_u, dh_œï, bch_u, bch_œï
end

function Degradation(œï, mat)
    # kmin = 1e-15;
    kmin = 1e-8;
    flagD = mat.flagD
    if flagD == QuadraticDegradation
        gd = (1.0 - œï)^2 + kmin; 
        gd‚Ä≤ = -2.0(1.0 - œï);
        gd‚Ä≤‚Ä≤ = 2.0;
    elseif flagD == WuDegradation
        a‚ÇÅ = mat.a‚ÇÅ;
        fact = (1.0 - œï)^2 + a‚ÇÅ*œï*(1 - 0.5œï);
        gd = (1.0 - œï)^2/fact + kmin;
        gd‚Ä≤ = -a‚ÇÅ*(1.0 - œï)/fact^2;
        gd‚Ä≤‚Ä≤ = 2a‚ÇÅ^2/fact^3 - 3a‚ÇÅ/fact^2;
        gd‚Ä≤‚Ä≤ = gd‚Ä≤‚Ä≤>0 ? gd‚Ä≤‚Ä≤ : 0;
    end
    return gd, gd‚Ä≤, gd‚Ä≤‚Ä≤
end

function Constitutive(Œµ::SymmetricTensor{2,3,Float64}, mat, gdn)
    Heaviside(x::AbstractFloat) = ifelse(x < 0, zero(x), ifelse(x > 0, one(x), oftype(x, 0.5)))
    flag = mat.flag
    if flag == Isotropic
        Œº = mat.G;
        Œª = mat.Œª;
        I = one(SymmetricTensor{2,3});
        ùïÄ = one(SymmetricTensor{4,3});
        D = Œª * I ‚äó I + 2Œº * ùïÄ;
        Œ®‚Å∫ = 0.5 * Œµ ‚ä° D ‚ä° Œµ;
        D·µâ = gdn * D; 
        œÉ = D·µâ ‚ä° Œµ;
        œÉ‚Å∫ = œÉ;
    elseif flag == VolDev 
        K = mat.K;
        G = mat.G;
        I = one(SymmetricTensor{2,3});
        ùïÄ = one(SymmetricTensor{4,3});
        D‚Å∫ = K * Heaviside(tr(Œµ)) * I ‚äó I + 2G * (ùïÄ - 1 / 3 * I ‚äó I);
        D‚Åª = K * Heaviside(-tr(Œµ)) * I ‚äó I;
        Œ®‚Å∫ = tr(Œµ) >0 ? 0.5*K*tr(Œµ)^2 + G*dev(Œµ) ‚ä° dev(Œµ) : G*dev(Œµ) ‚ä° dev(Œµ);
        œÉ‚Å∫ = tr(Œµ) >0 ? K*tr(Œµ)*I + 2G*dev(Œµ) : 2G*dev(Œµ); 
        œÉ‚Åª = tr(Œµ) <0 ? K*tr(Œµ)*I  : zero(Tensor{2, 3}); 
        D·µâ = gdn * D‚Å∫ + D‚Åª;
        œÉ = gdn *œÉ‚Å∫ + œÉ‚Åª;
    elseif flag == Spectral 
        Œµ‚Çô, V‚Çô = eigen(Œµ);        # Œµ‚Çô = eigvals(Œµ)
        Œº = mat.G;
        Œª = mat.Œª;
        bracket‚Çä(a::AbstractFloat) = a > 0 ? a : 0;
        bracket‚Çã(a::AbstractFloat) = a < 0 ? a : 0;
        H‚ÇÅ‚ÇÇ‚Å∫(x::AbstractFloat, y::AbstractFloat) = x ‚â† y ? (bracket‚Çä(x) - bracket‚Çä(y)) / (x - y) : Heaviside(x);
        H‚ÇÅ‚ÇÇ‚Åª(x::AbstractFloat, y::AbstractFloat) = x ‚â† y ? (bracket‚Çã(x) - bracket‚Çã(y)) / (x - y) : Heaviside(-x);
        I = one(SymmetricTensor{2,3});
        Œ®‚Å∫ = tr(Œµ) >0 ? Œª/2*tr(Œµ)^2 : 0.0;
        for e in Œµ‚Çô;Œ®‚Å∫ += e>0 ? Œº*e^2 : 0.0;end;
        œÉ‚Å∫ = Œª*bracket‚Çä(tr(Œµ))*I + 2Œº*(bracket‚Çä(Œµ‚Çô[1])*V‚Çô[:,1]‚äóV‚Çô[:,1] + bracket‚Çä(Œµ‚Çô[2])*V‚Çô[:,2]‚äóV‚Çô[:,2] + bracket‚Çä(Œµ‚Çô[3])*V‚Çô[:,3]‚äóV‚Çô[:,3]);
        œÉ‚Åª = Œª*bracket‚Çã(tr(Œµ))*I + 2Œº*(bracket‚Çã(Œµ‚Çô[1])*V‚Çô[:,1]‚äóV‚Çô[:,1] + bracket‚Çã(Œµ‚Çô[2])*V‚Çô[:,2]‚äóV‚Çô[:,2] + bracket‚Çã(Œµ‚Çô[3])*V‚Çô[:,3]‚äóV‚Çô[:,3]);
        D‚Å∫ = Œª * Heaviside(tr(Œµ)) * I ‚äó I;
        D‚Åª = Œª * Heaviside(-tr(Œµ)) * I ‚äó I;
        for a in 1:3
            D‚Å∫ += 2Œº * Heaviside(Œµ‚Çô[a]) * (V‚Çô[:, a] ‚äó V‚Çô[:, a]) ‚äó (V‚Çô[:, a] ‚äó V‚Çô[:, a]);
            D‚Åª += 2Œº * Heaviside(-Œµ‚Çô[a]) * (V‚Çô[:, a] ‚äó V‚Çô[:, a]) ‚äó (V‚Çô[:, a] ‚äó V‚Çô[:, a]);
            for b in 1:3
                if a ‚â† b
                    D‚Å∫ += Œº * H‚ÇÅ‚ÇÇ‚Å∫(Œµ‚Çô[a], Œµ‚Çô[b]) * ((V‚Çô[:, a] ‚äó V‚Çô[:, b]) ‚äó (V‚Çô[:, a] ‚äó V‚Çô[:, b]) + (V‚Çô[:, a] ‚äó V‚Çô[:, b]) ‚äó (V‚Çô[:, b] ‚äó V‚Çô[:, a]));
                    D‚Åª += Œº * H‚ÇÅ‚ÇÇ‚Åª(Œµ‚Çô[a], Œµ‚Çô[b]) * ((V‚Çô[:, a] ‚äó V‚Çô[:, b]) ‚äó (V‚Çô[:, a] ‚äó V‚Çô[:, b]) + (V‚Çô[:, a] ‚äó V‚Çô[:, b]) ‚äó (V‚Çô[:, b] ‚äó V‚Çô[:, a]));
                end
            end
        end
        D·µâ = gdn * D‚Å∫ + D‚Åª;
        œÉ = gdn *œÉ‚Å∫ + œÉ‚Åª;
    end
    return Œ®‚Å∫, D·µâ, œÉ, œÉ‚Å∫
end

function Newton_raphson!(q::Vector, K::SparseMatrixCSC, cellvalues, dh::DofHandler, ch::ConstraintHandler, grid::Grid, Mat::Material, states, states_old, Ru_first, Rœï_first, tag::String)
    iterations = 0;
    for nitr = 1:(solver.nitr_inner+1);
        if nitr > solver.nitr_inner;
            error("Reached maximum Newton iterations, aborting");
            break;
        end;
        K, r = assemble_global(q, cellvalues, K, dh, Mat, states, states_old, tag::String);
        apply_zero!(K, r, ch);
        norm_r = norm(r[Ferrite.free_dofs(ch)]);  # norm_r = maximum(abs.(r[Ferrite.free_dofs(ch)]))
        if tag =="u"
            TOL = solver.TOL_u * Ru_first;
        elseif tag =="œï"
            TOL = solver.TOL_œï * Rœï_first;
        end
        if (norm_r < TOL) && (nitr > 1);
            break;
        end
        iterations += 1;
        K_active = K[Ferrite.free_dofs(ch),Ferrite.free_dofs(ch)];
		r_active =  r[Ferrite.free_dofs(ch)];
        # Œîq = K_active \ r_active;
        q[Ferrite.free_dofs(ch)] -= K_active \ r_active;
    end
        print(tag*" converged in $iterations iterations \n");
    return q, iterations, K
end

function assemble_global(q::Vector, cellvalues, K::SparseMatrixCSC, dh::DofHandler, material::Material, states, states_old, tag::String)
    nbase = getnbasefunctions(cellvalues);

    Ke = zeros(nbase, nbase);
    Re = zeros(nbase);
    R = zeros(ndofs(dh));
    assembler = start_assemble(K, R);

    for (i, cell) in enumerate(CellIterator(dh))
        reinit!(cellvalues, cell);
        fill!(Ke, 0);
        fill!(Re, 0);
        eldofs = celldofs(cell);
        qe = q[eldofs];
        state = @view states[:, i];
        state_old = @view states_old[:, i];
        if tag == "u"
            assemble_element_u!(Ke, Re, cellvalues, qe, material, state, state_old);
        elseif  tag == "œï"
            assemble_element_œï!(Ke, Re, cellvalues, qe, material, state, state_old);
        end
        assemble!(assembler, eldofs, Ke, Re);
        
    end
    return K, R
end;

function Masterstep_u!(u, œï, K, R_u, R_œï, cellvalues_u, cellvalues_œï, dh, dh_u, dh_œï, ch, ch_u, ch_œï, material, states, states_old, flag_eta)
    @inbounds begin
        u_free = free_dofs(ch_u)
        œï_free = free_dofs(ch_œï)
        n_u = ndofs(dh_u)
        q = vcat(u, œï)  # ÂêàÂπ∂‰ΩçÁßªÂíåÁõ∏Âú∫ÁöÑËá™Áî±Â∫¶
        K = assemble_global_K_old(q, K, cellvalues_u, cellvalues_œï, dh, material, states, states_old)

        Kuu = @view K[1:n_u, 1:n_u]
        Kuœï = @view K[1:n_u, n_u+1:end]
        Kœïu = @view K[n_u+1:end, 1:n_u]
        Kœïœï = @view K[n_u+1:end, n_u+1:end]
        K_uu = @view (Kuu[u_free, u_free])
        K_uœï = @view (Kuœï[u_free, œï_free])
        K_œïu = @view (Kœïu[œï_free, u_free])
        K_œïœï = @view (Kœïœï[œï_free, œï_free])

        # Ru, states = assemble_global_r!(u, œï, cellvalues_u, cellvalues_œï, dh, dh_u, dh_œï, material, states, states_old, "u")
        # Rœï, _ = assemble_global_r!(u, œï, cellvalues_u, cellvalues_œï, dh, dh_u, dh_œï, material, states, states_old, "œï")

        # K_uu = sparse(Symmetric(K_uu))
        # K_œïœï = sparse(Symmetric(K_œïœï))
        # K_uu_fact = cholesky(K_uu)
        # K_œïœï_fact = cholesky(K_œïœï)
        # R_u = Ru[u_free]
        # R_œï = Rœï[œï_free]
        eta = 1;
        if flag_eta == 1
            rho = cal_rho1(K_uu, K_œïœï, K_uœï, K_œïu)
            
            if rho < 1
                eta = 1;
                println("eta = ", eta)
            elseif rho > 1
                eta = 0.9/sqrt(rho);
                println("eta = ", eta)
            end
        end

        y_active = Vector{Float64}(-(K_uu \ (R_u - eta * K_uœï * (K_œïœï \ R_œï))))
        # y_active = -(K_uu_fact \ (R_u - eta * K_uœï * (K_œïœï_fact \ R_œï)))
        # Profile.clear()
        # Œîu_active = gmres(v -> closure_M(K_uu, K_œïœï, K_uœï, K_œïu, v), y_active; eltype=Float64)

        Œîu_active = gmres_user(K_uu, K_œïœï, eta * K_uœï, eta * K_œïu, y_active; max_iter=50, tol=1e-6)
        # ProfileView.view()
        Œîu = zeros(ndofs(dh_u))
        #println("Œîu_activeËá™Áî±Â∫¶‰∏∫",length(Œîu_active))
        #println("Œîu[u_free]Ëá™Áî±Â∫¶‰∏∫",length(Œîu[u_free]))
        Œîu[u_free] .= Œîu_active
    end
    return Œîu
end

function assemble_coupled_K(u, œï, cellvalues_u, cellvalues_œï, dh_u, dh_œï, material, states, states_old)
    # ËÆ°ÁÆóÊÄªËá™Áî±Â∫¶Ôºö‰ΩçÁßª (u) + Áõ∏Âú∫ (œï)
    nu = ndofs(dh_u)
    nœï = ndofs(dh_œï)
    n_dofs = nu + nœï
    
    # ÂºÄÂßãÁªÑË£ÖÔºå‰∏çÊòæÂºèÊåáÂÆöÁ®ÄÁñèÊ®°Âºè
    assembler = start_assemble()
    
    # ÂÖÉÁ¥†Á∫ßÁöÑÁªÑË£Ö
    nbase_u = getnbasefunctions(cellvalues_u)  # ‰ΩçÁßªÂú∫ÁöÑÂü∫ÂáΩÊï∞Êï∞Èáè
    nbase_œï = getnbasefunctions(cellvalues_œï)  # Áõ∏Âú∫Âü∫ÂáΩÊï∞Êï∞Èáè
    Ke = BlockArray(zeros(nbase_u + nbase_œï, nbase_u + nbase_œï), [nbase_u, nbase_œï], [nbase_u, nbase_œï])
    
    # ÈÅçÂéÜÂçïÂÖÉ
    for (i, cell) in enumerate(CellIterator(dh_u.grid))
        fill!(Ke, 0)  # Ê∏ÖÁ©∫ÂÖÉÁ¥†ÂàöÂ∫¶Áü©Èòµ
        reinit!(cellvalues_u, cell)  # ÈáçÁΩÆÂçïÂÖÉÂÄº
        reinit!(cellvalues_œï, cell)
        
        # Ëé∑ÂèñÂçïÂÖÉËá™Áî±Â∫¶
        eldofs_u = celldofs(dh_u, i)
        eldofs_œï = celldofs(dh_œï, i)
        eldofs = vcat(eldofs_u, eldofs_œï)  # ÂêàÂπ∂Ëá™Áî±Â∫¶
        
        # Ëé∑ÂèñÂçïÂÖÉËß£ÂêëÈáè
        ue = u[eldofs_u]
        œïe = œï[eldofs_œï]
        qe = vcat(ue, œïe)  # ÂêàÂπ∂Ëß£ÂêëÈáè
        
        state = @view states[:, i]
        state_old = @view states_old[:, i]
        
        # ÁªÑË£ÖÂÖÉÁ¥†ÂàöÂ∫¶Áü©Èòµ
        assemble_element_ke_old!(Ke, cell, cellvalues_u, cellvalues_œï, qe, material, state, state_old)
        
        # Â∞ÜÂÖÉÁ¥†Áü©ÈòµÁªÑË£ÖÂà∞ÂÖ®Â±ÄÁü©Èòµ
        assemble!(assembler, eldofs, Ke)
    end
    
    # ÂÆåÊàêÁªÑË£ÖÂπ∂ËøîÂõûÂÖ®Â±ÄÁü©Èòµ
    K, _ = end_assemble(assembler)
    return K
end

function assemble_element_ke_old!(Ke, cell, cellvalues_u, cellvalues_œï, qe, material, state, state_old)
    nbase_u = getnbasefunctions(cellvalues_u)
    nbase_œï = getnbasefunctions(cellvalues_œï)
    u‚ñÑ, œï‚ñÑ = 1, 2 #‰ΩçÁßªÊòØÂùó1ÔºåÁõ∏Âú∫ÊòØÂùó2
    reinit!(cellvalues_u, cell)
    reinit!(cellvalues_œï, cell)

    œïe = qe[nbase_u+1:end]
    ue = qe[1:nbase_u]

    Gc = material.Gc
    ‚Ñì = material.‚Ñì

    for q_point in 1:getnquadpoints(cellvalues_u)
        dŒ©·µ§ = getdetJdV(cellvalues_u, q_point)
        if material.dim == 2
            Œµ_PlaneStrain = function_symmetric_gradient(cellvalues_u, q_point, ue)
            ‚àáÀ¢u = SymmetricTensor{2,3,Float64}((Œµ_PlaneStrain[1, 1], Œµ_PlaneStrain[1, 2], 0.0,Œµ_PlaneStrain[2, 2], 0.0, 0.0))
        elseif material.dim == 3
            ‚àáÀ¢u = function_symmetric_gradient(cellvalues_u, q_point, ue)
        else
            error("Invalid element dimension")
        end

        œï = state[q_point].œï
        gd, gd‚Ä≤, gd‚Ä≤‚Ä≤  = Degradation(œï, material);
        Œ®‚Å∫, D·µâ, œÉ, œÉ‚Å∫ = Constitutive(‚àáÀ¢u, material, gd);
        H = max(Œ®‚Å∫, state_old[q_point].H);
        #state[q_point] = HistoryVariable(H, œï);

        for i in 1:nbase_u
            if material.dim == 2
                Œ¥Œµ_2d = shape_symmetric_gradient(cellvalues_u, q_point, i);
                Œ¥Œµ = SymmetricTensor{2,3,Float64}((Œ¥Œµ_2d[1, 1], Œ¥Œµ_2d[1, 2], 0.0,Œ¥Œµ_2d[2, 2], 0.0, 0.0));
            else
                Œ¥Œµ = shape_symmetric_gradient(cellvalues_u, q_point, i);
            end
            for j in 1:nbase_u
                if material.dim == 2
                    Œµ_2d = shape_symmetric_gradient(cellvalues_u, q_point, j);
                    ŒµÃÑu = SymmetricTensor{2,3,Float64}((Œµ_2d[1, 1], Œµ_2d[1, 2], 0.0,
                        Œµ_2d[2, 2], 0.0, 0.0));
                else
                    ŒµÃÑu = shape_symmetric_gradient(cellvalues_u, q_point, j);
                end
                Ke[BlockIndex((u‚ñÑ, u‚ñÑ), (i, j))] += Œ¥Œµ ‚ä° D·µâ ‚ä° ŒµÃÑu * dŒ©·µ§  #Œµ ÊòØ B and Œ¥Œµ ÊòØ B·µÄ ÊïÖ B·µÄDB
            end
            for j in 1:nbase_œï
                œï‚Ä≤ = shape_value(cellvalues_œï, q_point, j)
                Ke[BlockIndex((u‚ñÑ, œï‚ñÑ), (i, j))] += (gd‚Ä≤ * Œ¥Œµ ‚ä° œÉ‚Å∫ * œï‚Ä≤) * dŒ©·µ§
            end
        end
        for i in 1:nbase_œï
            Œ¥œï = shape_value(cellvalues_œï, q_point, i)
            ‚àáŒ¥œï = shape_gradient(cellvalues_œï, q_point, i)
            for j in 1:nbase_œï
                œï‚Ä≤ = shape_value(cellvalues_œï, q_point, j)
                ‚àáœï‚Ä≤ = shape_gradient(cellvalues_œï, q_point, j)
                Ke[BlockIndex((œï‚ñÑ, œï‚ñÑ), (i, j))] += (gd‚Ä≤‚Ä≤ * œï‚Ä≤ * H * Œ¥œï + Gc / ‚Ñì *Œ¥œï * œï‚Ä≤ +  Gc *‚Ñì * ‚àáŒ¥œï ‚ãÖ ‚àáœï‚Ä≤) * dŒ©·µ§
            end
            for j in 1:nbase_u
                if material.dim == 2
                    Œµ_2d = shape_symmetric_gradient(cellvalues_u, q_point, j);
                    ŒµÃÑu = SymmetricTensor{2,3,Float64}((Œµ_2d[1, 1], Œµ_2d[1, 2], 0.0,
                        Œµ_2d[2, 2], 0.0, 0.0));
                else
                    ŒµÃÑu = shape_symmetric_gradient(cellvalues_u, q_point, j);
                end
                if state[q_point].H > state_old[q_point].H
                    Ke[BlockIndex((œï‚ñÑ, u‚ñÑ), (i, j))] += (gd‚Ä≤ *Œ¥œï * œÉ‚Å∫ ‚ä° ŒµÃÑu) * dŒ©·µ§
                else
                    Ke[BlockIndex((œï‚ñÑ, u‚ñÑ), (i, j))] += 0.0
                end   
            end
        end
    end    
end

function closure_M(K_uu, K_œïœï, K_uœï, K_œïu, x::Vector{Float64})::Vector{Float64}
    result = x - K_uu\(K_uœï*(K_œïœï\(K_œïu*x)));
    return result
end

# function cal_rho(K_uu, K_œïœï, K_uœï, K_œïu, R_u) # ËÄÅÂäûÊ≥ïËÆ°ÁÆórho
#     max_iter = 20  # ÊúÄÂ§ßËø≠‰ª£Ê¨°Êï∞
#     tol = 1e-2    # Êî∂ÊïõÂÆπÂ∑Æ
#     R_u_old = R_u
#     rho = 0.0     # ÂàùÂßãÂåñ rho
#     prev_rho = 0.0  # ‰∏ä‰∏ÄÊ¨°ÁöÑ rho ÂÄº
#     for i ‚àà 1:max_iter
#         R_u_new = K_uu \ (K_uœï * (K_œïœï \ (K_œïu * R_u_old)))
#         rho = norm(R_u_new) / norm(R_u_old)
#         if abs(rho - prev_rho) < tol
#             println("cal_rho: Converged at iteration $i with rho_diff = $(abs(rho - prev_rho))")
#             return rho
#         end
#         prev_rho = rho
#         R_u_old = R_u_new
#     end
#     println("cal_rho: Reached max_iter without convergence")
#     return rho
# end

function cal_rho(K_uu, K_œïœï, K_uœï, K_œïu, R_u, k; max_iter=20, tol=1e-2)
    # ÂàùÂßãÂåñÁ®ÄÁñèÂêëÈáè
    R_u_old = R_u
    rho = 0.0
    prev_rho = 0.0
    converged = false

    for i in 1:max_iter
        # ËÆ°ÁÆóÊñ∞ÁöÑ R_u
        R_u_new = K_uu \ (K_uœï * (K_œïœï \ (K_œïu * R_u_old)))

        # Êà™Êñ≠Êìç‰ΩúÔºö‰øùÁïôÂâç k ‰∏™ÊúÄÂ§ßÁöÑÂÖÉÁ¥†
        R_u_new = truncate_vector(R_u_new, k)

        # ËÆ°ÁÆó rho
        rho = norm(R_u_new) / norm(R_u_old)

        # Ê£ÄÊü•Êî∂ÊïõÊÄß
        if abs(rho - prev_rho) < tol
            println("cal_rho: Converged at iteration $i with rho_diff = $(abs(rho - prev_rho))")
            converged = true
            break
        end

        prev_rho = rho
        R_u_old = R_u_new
    end

    if !converged
        println("cal_rho: Reached max_iter without convergence")
    end

    return rho
end

function cal_rho1(K_uu, K_œïœï, K_uœï, K_œïu)
    n = size(K_uu, 1)  # K_uu ÁöÑË°åÊï∞
    m = size(K_œïœï, 1)  # K_œïœï ÁöÑË°åÊï∞
    A_top = hcat(zeros(n, n), -K_uœï)        # Á¨¨‰∏ÄË°åÂùó: [0 | -K_uœï]
    A_bottom = hcat(zeros(m, n), zeros(m, m)) # Á¨¨‰∫åË°åÂùó: [0 | 0]
    A = vcat(A_top, A_bottom)

    # ÊûÑÈÄ†ÂÆåÊï¥Áü©Èòµ BÔºàÂè≥‰æßÁü©ÈòµÔºâ
    B_top = hcat(K_uu, zeros(n, m))          # Á¨¨‰∏ÄË°åÂùó: [K_uu | 0]
    B_bottom = hcat(K_œïu, K_œïœï)              # Á¨¨‰∫åË°åÂùó: [K_vu | K_vv]
    B = vcat(B_top, B_bottom)
    rho = eigs(sparse(A), sparse(B); nev=1, which=:LM, tol=1e-2)[1]  # Âè™ÊèêÂèñÊ®°ÊúÄÂ§ßÁöÑÁâπÂæÅÂÄº
    rho = abs.(rho)
    rho = Float64(rho[])
    return rho
end

# Êà™Êñ≠ÂáΩÊï∞Ôºö‰øùÁïôÂâç k ‰∏™ÊúÄÂ§ßÁöÑÂÖÉÁ¥†
function truncate_vector(x, k)
    # Á°Æ‰øù k ÊòØÊï¥Êï∞
    k = Int(round(k))
    
    # Ëé∑ÂèñÁªùÂØπÂÄºÊúÄÂ§ßÁöÑ k ‰∏™ÂÖÉÁ¥†ÁöÑÁ¥¢Âºï
    idx = sortperm(abs.(x), rev=true)[1:k]
    
    # ÂàõÂª∫‰∏Ä‰∏™Êñ∞ÁöÑÂêëÈáèÔºåÂè™‰øùÁïôÂâç k ‰∏™ÊúÄÂ§ßÁöÑÂÖÉÁ¥†ÔºåÂÖ∂‰ΩôÁΩÆÈõ∂
    truncated_x = zeros(length(x))
    truncated_x[idx] = x[idx]
    return truncated_x
end

function gmres_user(K11, K22, K12, K21, b; max_iter=50, tol=1e-6)
    n = length(b)
    x0 = zeros(n)
    r0 = b - closure_M(K11, K22, K12, K21, x0)
    Œ≤ = norm(r0)
    

    V = zeros(n, max_iter + 1)
    V[:, 1] = r0 / Œ≤
    Œæ = zeros(max_iter + 1)
    Œæ[1] = Œ≤
    H = zeros(max_iter + 1, max_iter)
    c = zeros(max_iter)
    s = zeros(max_iter)

    j = 0
    @inbounds for j in 1:max_iter
        # Arnoldi ËøáÁ®ã
        w = closure_M(K11, K22, K12, K21, V[:, j])
        for i in 1:j
            H[i, j] = dot(V[:, i], w)
            w -= H[i, j] * V[:, i]
        end
        for i in 1:j
            h_ij = dot(V[:, i], w)
            H[i, j] += h_ij
            w -= h_ij * V[:, i]
        end
        H[j+1, j] = norm(w)
        if H[j+1, j] < eps() * Œ≤
            break
        end
        V[:, j+1] = w / H[j+1, j]

        # Givens ÊóãËΩ¨
        for i in 1:j-1
            temp = c[i] * H[i, j] + s[i] * H[i+1, j]
            H[i+1, j] = -s[i] * H[i, j] + c[i] * H[i+1, j]
            H[i, j] = temp
        end
        rho = sqrt(H[j, j]^2 + H[j+1, j]^2)
        if rho != 0
            c[j] = H[j, j] / rho
            s[j] = H[j+1, j] / rho
            H[j, j] = rho
            H[j+1, j] = 0.0
        else
            c[j] = 1.0
            s[j] = 0.0
        end

        # Êõ¥Êñ∞ Œæ
        Œæ[j+1] = -s[j] * Œæ[j]
        Œæ[j] = c[j] * Œæ[j]

        relres = abs(Œæ[j+1]) / Œ≤
        if relres < tol 
            y = UpperTriangular(H[1:j, 1:j]) \ Œæ[1:j]
            x = x0 + V[:, 1:j] * y
            println("Á¨¨ $j Ê¨°Ëø≠‰ª£Êî∂ÊïõÔºåÁõ∏ÂØπÊÆãÂ∑Æ‰∏∫ $relres")
            return x
        end
    end

    # Â¶ÇÊûúËææÂà∞ÊúÄÂ§ßËø≠‰ª£Ê¨°Êï∞ÊàñÈúÄË¶ÅÊúÄÁªàËß£
    y = UpperTriangular(H[1:j, 1:j]) \ Œæ[1:j]
    x = x0 + V[:, 1:j] * y
    relres = abs(Œæ[j+1]) / Œ≤
    println("Ëø≠‰ª£ $j Ê¨°Êú™Êî∂ÊïõÔºåÁõ∏ÂØπÊÆãÂ∑Æ‰∏∫ $relres")
    return x
end

function assemble_global_K_old(q, K, cellvalues_u,cellvalues_œï, dh, material, states, states_old)

    assembler = start_assemble(K)
    nu = getnbasefunctions(cellvalues_u)
    nœï = getnbasefunctions(cellvalues_œï)

    Ke = BlockArray(zeros(nu + nœï, nu + nœï), [nu, nœï], [nu, nœï]) # local stiffness matrix
    for (i, cell)  in enumerate(CellIterator(dh))
        fill!(Ke, 0)
        reinit!(cellvalues_œï, cell);
        reinit!(cellvalues_u, cell);
        eldofs = celldofs(cell)
        qe = q[eldofs]
        state = @view states[:, i]
        state_old = @view states_old[:, i]
        assemble_element_ke_old!(Ke, cell, cellvalues_u, cellvalues_œï, qe, material, state, state_old)

        assemble!(assembler, eldofs, Ke)
    end
    return K
end

function OutputForce(u, cellvalues_u, dh_u, grid, material, states, states_old, set::String, tag)
	F = assemble_global_r(u, cellvalues_u, dh_u, material, states, states_old, tag, true);
	F_x = 0.0;
	F_y = 0.0;
	Fnodal = reshape_to_nodes(dh_u, F, :u);
    # Fnodal = evaluate_at_grid_nodes(dh, F, :u);
	if set ‚àà keys(grid.nodesets);
		outputset = grid.nodesets[set];
	elseif set ‚àà keys(grid.facesets[set]);
		print("facesets are currently not supported for force output");
	else;
		print("Warning invalid set for force output");
	end;
	for (i, n) in enumerate(grid.nodesets[set]);
		F_x += Fnodal[1, n];
		F_y += Fnodal[2, n];
		# F_x += Fnodal[i][1];
		# F_y += Fnodal[i][2];
	end;
	return F_x, F_y;
end;
function CrackTrack(q, dh, cellValues, grid, a0, CrackDir)
	Ac = a0
	v = CrackDir
	for (i, cell) in enumerate(CellIterator(dh))
		reinit!(cellValues, cell)
		eldofs = celldofs(cell)
		œïe = q[eldofs]
		if maximum(œïe) >= 0.95
			node_coords = getcoordinates(grid, i)
			for q_point in 1:getnquadpoints(cellValues)
				#Phase field value
				œï = function_value(cellValues, q_point, œïe)
				if œï >= 0.95
					coords = spatial_coordinate(cellValues, q_point, node_coords)
					Ac = coords[v] > Ac ? coords[v] : Ac
				end
			end
		end
	end
	return Ac
end
function write_to_txt(filename, variable)
    open(filename, "w") do file
        write(file, string(variable))  # Â∞ÜÂèòÈáèËΩ¨Êç¢‰∏∫Â≠óÁ¨¶‰∏≤ÂÜôÂÖ•Êñá‰ª∂
    end
end
function save_results(folder, timestep, u, œï, states, states_old)
    # Á°Æ‰øùÊñá‰ª∂Â§πÂ≠òÂú®ÔºåÂ¶ÇÊûú‰∏çÂ≠òÂú®ÂàôÂàõÂª∫
    if !isdir(folder)
        mkdir(folder)
    end

    # Â∞ÜÊó∂Èó¥Ê≠•Ê†ºÂºèÂåñ‰∏∫Â≠óÁ¨¶‰∏≤Ôºå‰øùÁïô 5 ‰ΩçÂ∞èÊï∞ÔºåÂπ∂Áî®‰∏ãÂàíÁ∫øÊõø‰ª£Â∞èÊï∞ÁÇπ
    timestep_str = replace(@sprintf("%.5f", timestep), "." => "_")
    filename = joinpath(folder, "time_$timestep_str.jld")  # Â∞ÜÊñá‰ª∂‰øùÂ≠òÂà∞ÊåáÂÆöÊñá‰ª∂Â§π
    save(filename, "timestep", timestep, "u", u, "œï", œï, "states", states, "states_old", states_old)
end
function load_results(folder, timestep)
    # Â∞ÜÊó∂Èó¥Ê≠•Ê†ºÂºèÂåñ‰∏∫Â≠óÁ¨¶‰∏≤Ôºå‰øùÁïô 5 ‰ΩçÂ∞èÊï∞ÔºåÂπ∂Áî®‰∏ãÂàíÁ∫øÊõø‰ª£Â∞èÊï∞ÁÇπ
    timestep_str = replace(@sprintf("%.5f", timestep), "." => "_")
    filename = joinpath(folder, "time_$timestep_str.jld")  # ‰ªéÊåáÂÆöÊñá‰ª∂Â§πÂä†ËΩΩÊñá‰ª∂
    if !isfile(filename)
        error("File $filename does not exist.")
    end
    data = load(filename)
    return data["timestep"], data["u"], data["œï"], data["states"], data["states_old"]
end

function updatePsi(cellvalues_u, u, dh_u, material, states, states_old)
    for (i, cell) in enumerate(CellIterator(dh_u))
        reinit!(cellvalues_u, cell)
        eldofs_u = celldofs(cell)         # ÈíàÂØπdh_uÔºåÁºñÂè∑Â∞±ÊòØuÂú∫ÁöÑÊú¨Âú∞ÁºñÂè∑
        ue = u[eldofs_u]
        state = @view states[:, i]
        state_old = @view states_old[:, i]
        states[:, i] = assemble_element_psi!(cellvalues_u, ue, material, state, state_old)
    end
    return states
end

function assemble_element_psi!(cellvalues_u,ue::Vector, material::Material, state, state_old)
    for q_point in 1:getnquadpoints(cellvalues_u)
        œï = state[q_point].œï;
        if material.dim == 2
            Œµ_PlaneStrain = function_symmetric_gradient(cellvalues_u, q_point, ue);
            ‚àáÀ¢u = SymmetricTensor{2,3,Float64}((Œµ_PlaneStrain[1, 1], Œµ_PlaneStrain[1, 2], 0.0, Œµ_PlaneStrain[2, 2], 0.0, 0.0));
        elseif material.dim == 3
            ‚àáÀ¢u = function_symmetric_gradient(cellvalues_u, q_point, ue) - ŒµŒ∏*one(SymmetricTensor{2, 3});
        else
            error("Invalid element dimension");
        end
        
        gd, _, _ = Degradation(œï, material);
        Œ®‚Å∫, _, œÉ, _ = Constitutive(‚àáÀ¢u, material, gd);
        H = max(Œ®‚Å∫, state_old[q_point].H);
        state[q_point] = HistoryVariable(H, œï);
    end
    return state
end
